#!/usr/bin/env rua
-- quick point visualization of the dynamic vars
local vec3d = require 'vec-ffi.vec3d'
local gl = require 'gl'
local glreport = require 'gl.report'
local GLSceneObject = require 'gl.sceneobject'
local GLTex2D = require 'gl.tex2d'
local GLFBO = require 'gl.fbo'
local ig = require 'imgui'

local App = require 'imgui.appwithorbit'()

App.title = 'NASA Horizons Data Viewer'
App.viewDist = 1e+11
App.initGL = |:, ...| do
	App.super.initGL(self, ...)
glreport'here'

	self.view.znear = 1e+3
	self.view.zfar = 1e+23

	self.pointObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
layout(location=0) in vec3 vertex;
layout(location=1) in vec3 color;
layout(location=2) in int id;
out vec3 colorv;
out flat int idv;
uniform mat4 mvProjMat;
void main() {
	gl_Position = mvProjMat * vec4(vertex, 1.);
	colorv = color;
	idv = id;//gl_VertexID;
}
]],
			fragmentCode = [[
in vec3 colorv;	//TODO NOTICE with this typo'd as "color" I was getting segfaults.
in flat int idv;
layout(location=0) out vec4 fragColor;
layout(location=1) out int fragID;
void main() {
	fragColor = vec4(colorv, 1.);
	fragID = idv;
}
]],
		},
		geometry = {
			mode = gl.GL_POINTS,
		},
		vertexes = {
			useVec = true,
			dim = 3,
		},
		attrs = {
			color = {
				buffer = {
					useVec = true,
					dim = 3,
				},
			},
			id = {
				buffer = {
					useVec = true,
					dim = 1,
					ctype = 'int32_t',
				},
			},
		},
	}
glreport'here'

	self.lineObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
layout(location=0) in vec3 vertex;
layout(location=1) in vec3 color;
out vec3 colorv;
uniform mat4 mvProjMat;
void main() {
	gl_Position = mvProjMat * vec4(vertex, 1.);
	colorv = color;
}
]],
			fragmentCode = [[
in vec3 colorv;
out vec4 fragColor;
void main() {
	fragColor = vec4(colorv, 1.);
}
]],
		},
		geometry = {
			mode = gl.GL_LINES,
		},
		vertexes = {
			useVec = true,
			dim = 3,
		},
		attrs = {
			color = {
				buffer = {
					useVec = true,
					dim = 3,
				},
			},
		},
	}
glreport'here'


	self.blitObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
out vec2 tc;
void main() {
	tc = vertex;
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
}
]],
			fragmentCode = [[
in vec2 tc;
out vec4 fragColor;
uniform sampler2D tex;
void main() {
	fragColor = texture(tex, tc);
}
]],
			uniforms = {
				tex = 0,
			},
		},
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
		vertexes = {
			data = {0,0, 1,0, 0,1, 1,1},
			dim = 2,
		},
	}

glreport'here'

	self:buildFBO()
glreport'here'

	local lineVtxs = self.lineObj.attrs.vertex.buffer:beginUpdate()
	local lineColors = self.lineObj.attrs.color.buffer:beginUpdate()

	-- make axis in center
	for i=0,2 do
		lineVtxs:emplace_back()
		local v = lineVtxs:emplace_back()
		v.s[i] = 1e+3

		local v = lineColors:emplace_back()
		v.s[i] = 1
		local v = lineColors:emplace_back()
		v.s[i] = 1
	end

	local pointVtxs = self.pointObj.attrs.vertex.buffer:beginUpdate()
	local pointColors = self.pointObj.attrs.color.buffer:beginUpdate()
	local pointIDs = self.pointObj.attrs.id.buffer:beginUpdate()

	local json = require 'dkjson'

	self.bodies = json.decode((path'dynamic-vars.json':read():match'.-=(.*)')).coords
	self.bodyForID = {}
	for i,body in ipairs(self.bodies) do
		for j=1,3 do
			body.pos[j] = assert(tonumber(body.pos[j]:lower():trim())) * 1e+3 -- convert km to m
			body.vel[j] = assert(tonumber(body.vel[j]:lower():trim())) * 1e+3
		end
		body.pos = vec3d(table.unpack(body.pos))
		body.vel = vec3d(table.unpack(body.vel))
		body.color = vec3d():map(|| math.random()):normalize()

		body.id = assert(tonumber(body.id))
		assert.eq(self.bodyForID[body.id], nil)
		self.bodyForID[body.id] = body

		pointVtxs:emplace_back():set(body.pos:unpack())
		pointColors:emplace_back():set(body.color:unpack())
		pointIDs:emplace_back()[0] = body.id
	end

	self.bodyForName = {}
	for _,bodyStaticVars in ipairs(
		json.decode((
			path'static-vars.json':read():match'^horizonsStaticData = (.*)'
		))
	) do
		local body = self.bodyForID![bodyStaticVars.id]
		body.name = bodyStaticVars.name

		for k,v in pairs(bodyStaticVars) do
			if not body[k] then
				body[k] = v
			end
		end

		if self.bodyForName[body.name] then
			error("have duplicate entries for name "..tostring(body.name))
		end
		self.bodyForName[body.name] = body
	end

	local Julian = require 'solarsystem.julian'
	local KOE = require 'solarsystem.koe'
	local initJulianDate = Julian.fromCalendar(os.date'!*t')
	for index,body in ipairs(self.bodies) do
		if body.parent then
			local parentBody = self.bodyForName![body.parent]
			body.parentBody = parentBody
			body.parentIndex = table.find(self.bodies, parentBody)
			assert.lt(body.parentIndex, index)
		end
		body.mass ??= 0
	end

	-- now that all parents are found, recursively sum their childrens masses
	for index=#self.bodies,1,-1 do
		local body = self.bodies[index]
		local parentBody = body.parentBody
		if parentBody then
			parentBody.mass += body.mass
		end
	end

	local inclinationVsDistancePerBody = table()
	for _,body in ipairs(self.bodies) do
		local parentBody = body.parentBody
		if parentBody then
			if body.pos ~= parentBody.pos then
				local koe = KOE.calcKOEFromPosVel(body, self.bodies, initJulianDate)
				body.koe = koe
			
				-- TODO instead of first do weighted-by-inverse-distance?
				if not parentBody.firstOrbitBasis then
					parentBody.firstOrbitBasis = body.koe.orbitBasis
				end

inclinationVsDistancePerBody[body.parentIndex] ??= table()
inclinationVsDistancePerBody[body.parentIndex]:insert{
	koe.distanceToParent,
	--koe.inclination,	-- inclination parameter is relative to coordinate system
	math.deg(math.asin(math.abs(
	parentBody.firstOrbitBasis[3]:dot((body.pos - parentBody.pos):normalize())
	)))
}
				-- now add KOE ellipses
				local n = 100
				local lastv
				for i=0,n do
					local t = (i/n - .5) * koe.orbitalPeriod

					local pushMeanAnomaly = koe.meanAnomaly
					local pushEccentricAnomaly = koe.eccentricAnomaly
					local pushFractionOffset = koe.fractionOffset
					local out = {}
					KOE.updatePosVel(out, koe, initJulianDate + t, initJulianDate)
					koe.meanAnomaly = pushMeanAnomaly
					koe.eccentricAnomaly = pushEccentricAnomaly
					koe.fractionOffset = pushFractionOffset

					local v = parentBody.pos + out.pos_koe --body.koe.A * math.cos(t) + body.koe.B * math.sin(t)
					if lastv then
						lineVtxs:emplace_back():set(lastv:unpack())
						lineVtxs:emplace_back():set(v:unpack())
						lineColors:emplace_back():set(body.color:unpack())
						lineColors:emplace_back():set(body.color:unpack())
					end
					lastv = v
				end
			end
		end
	end

	self.pointObj:endUpdate()
	self.lineObj:endUpdate()


-- I want to normalize all distances-vs-inclinations across all planets
-- kepler's 1-2-3 rule:
-- μ * (T/2π)^2 = a^3
-- where μ = G (M + m) = gravitational parameter
-- T = orbital period
-- a = semi-major axis
-- ω = 2π/T = orbital angular velocity
-- μ = ω^2 a^3
-- so
-- a = (μ / ω^2)^(1/3)
--
-- maybe inclination is inverse-proportional to rotation speed, which is inverse-proportional to distance?
-- [=[
	local p = path'dist-vs-incl'
	p:mkdir()
	local gnuplot = require 'gnuplot'
	local matrix = require 'matrix'
	--KOE.gravitationalConstant = 6.6738480e-11	-- m^3 / (kg * s^2)
	local G = KOE.gravitationalConstant
	local alldata = table()
	local allusings = table()
	for _,id in ipairs(inclinationVsDistancePerBody:keys():sort()) do
		local body = self.bodies[id]
		local data = matrix(
			inclinationVsDistancePerBody[id]
				:sort(|a,b| a[1] < b[1])
				-- [[ trying to normalize all planets distance data to the same scale
				-- parent body.mass == total mass of the barycenter system (kg)
				-- G * body.mass = mu = gravitational parameter (m^3/s^2)
				:mapi(|x| {x[1] / (G * body.mass), x[2]})
				--]]
		):T()
		alldata:append(data)
		allusings:insert{using=(#alldata-1)..':'..(#alldata), title=body.name}
		gnuplot{
			terminal = 'svg size 1024,768',
			output = p(body.name..'.svg').path,
			key = {'left'},
			xlabel = 'dist (m) / gravitational parameter (m^3 / s^2)',
			ylabel = 'orbital inclination angle (deg)',
			log = 'xy',
			data = data,
			savedata = p(body.name..'.txt').path,
			title = body.name,
			{using='1:2', notitle=true},
		}
	end
--[[ add rings
solar system - asteroid belt:	average distance: 9.656e+8 m
jupiter rings:	9.2e+7 - 2.26e+8 m
saturn rings:	6.69e+7 - 4.8e+8 m
uranus rings:	3.8e+7 - 9.8e+7 m
neptune rings:	4.19e+7 - 6.29e+7 m
--]]
	for _,info in ipairs{
		{'Solar System Barycenter', 9.969e+8}, 
		{'Jupiter Barycenter', 9.2e+7, 2.26e+8}, 
		{'Saturn Barycenter', 6.69e+7, 4.8e+8}, 
		{'Uranus Barycenter', 3.8e+7, 9.8e+7}, 
		{'Neptune Barycenter', 4.19e+7, 6.29e+7}, 
	} do
		local name = table.remove(info, 1)
		local body = self.bodyForName![name]
		alldata:append{
			table.mapi(info, |dist| dist / (G * body.mass)), 
			table{0}:rep(#info),
		}
		allusings:insert{using=(#alldata-1)..':'..(#alldata), title=name}
	end
--]]
	gnuplot(table(allusings, {
		terminal = 'svg size 1024,768',
		output = p'all.svg'.path,
		key = {'left'},
		xlabel = 'dist (m) / gravitational parameter (m^3 / s^2)',
		ylabel = 'orbital plane inclination angle (deg)',
		log = 'x',
		data = alldata,
		savedata = p'all.txt'.path,
	}))

	os.exit()
--]=]

glreport'here'

	--print(require'gl.global':get'GL_READ_BUFFER')	-- GL_BACK is default
end

App.resize = |:, ...| do
	App.super.resize(self, ...)
	self:buildFBO()
end

App.buildFBO = |:|do
	local width = self.width
	local height = self.height

	self.fb?:delete()
glreport'here'
	self.fbColorTex?:delete()
glreport'here'
	self.fbIDTex?:delete()
glreport'here'
	self.fbDepthTex?:delete()
glreport'here'


	self.fbColorTex = GLTex2D{
		width = width,
		height = height,
		internalFormat = gl.GL_RGB,
		minFilter = gl.GL_NEAREST,
		magFilter = gl.GL_NEAREST,
		wrap = {
			s = gl.GL_CLAMP_TO_EDGE,
			t = gl.GL_CLAMP_TO_EDGE,
		},
	}
glreport'here'

	self.fbIDTex = GLTex2D{
		width = width,
		height = height,
		internalFormat = gl.GL_R32I,
		minFilter = gl.GL_NEAREST,
		magFilter = gl.GL_NEAREST,
		wrap = {
			s = gl.GL_CLAMP_TO_EDGE,
			t = gl.GL_CLAMP_TO_EDGE,
		},
	}
glreport'here'

	self.fbDepthTex = GLTex2D{
		width = self.width,
		height = self.height,
		internalFormat = gl.GL_DEPTH_COMPONENT,
		minFilter = gl.GL_NEAREST,
		magFilter = gl.GL_NEAREST,
		wrap = {
			s = gl.GL_CLAMP_TO_EDGE,
			t = gl.GL_CLAMP_TO_EDGE,
		},
	}
glreport'here'


	-- set up FBO

	self.fb = GLFBO{
		width = width,
		height = height,
	}
glreport'here'

	self.fbColorTex:bind()
glreport'here'
	self.fb:setColorAttachmentTex2D(self.fbColorTex.id, 0, self.fbColorTex.target)
	--gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, gl.GL_COLOR_ATTACHMENT0, gl.GL_TEXTURE_2D, self.fbColorTex.id, 0)
glreport'here'
	self.fbColorTex:unbind()
glreport'here'


	-- why would this get an error?  what's the harm in binding an already-bound framebuffer?
	--self.fb:bind()
	--glreport'here'
	self.fbIDTex:bind()
glreport'here'
	self.fb:setColorAttachmentTex2D(self.fbIDTex.id, 1, self.fbIDTex.target)
	--gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, gl.GL_COLOR_ATTACHMENT1, gl.GL_TEXTURE_2D, self.fbIDTex.id, 0)
glreport'here'
	self.fbIDTex:unbind()
glreport'here'

	self.fbDepthTex:bind()
glreport'here'
	gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, gl.GL_DEPTH_ATTACHMENT, self.fbDepthTex.target, self.fbDepthTex.id, 0)
glreport'here'
	self.fbDepthTex:unbind()
glreport'here'

	self.fb:setDrawBuffers(
		gl.GL_COLOR_ATTACHMENT0,	-- fragColor
		gl.GL_COLOR_ATTACHMENT1)	-- fragID
glreport'here'

	self.fb:unbind()
glreport'here'

	-- done setting up FBO

	self.blitObj.texs[1] = self.fbColorTex
end


local clearColor = ffi.new('float[4]', 0,0,0,0)
local clearID = ffi.new('int32_t[1]', -1)
local readID = ffi.new('int32_t[1]', -1)

App.update = |:, ...| do
glreport'here'
	self.fb:bind()
glreport'here'
	GLFBO.check()
glreport'here'

	gl.glClear(gl.GL_DEPTH_BUFFER_BIT)
glreport'here'
	gl.glClearBufferfv(gl.GL_COLOR, 0, clearColor)
glreport'here'
	gl.glClearBufferiv(gl.GL_COLOR, 1, clearID)
glreport'here'

	gl.glPointSize(5)
glreport'here'
	self.pointObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
	self.pointObj:draw()
glreport'here'
	gl.glPointSize(1)
glreport'here'

	-- now while we're here, read the mouse coord of fbIDTex
	readID[0] = -1
	gl.glReadBuffer(gl.GL_COLOR_ATTACHMENT1)	-- set this once? reset after? nah?
glreport'here'
	gl.glReadPixels(
		self.mouse.ipos.x,
		self.height - 1 - self.mouse.ipos.y,
		1,
		1,
		self.fbIDTex.format,
		self.fbIDTex.type,
		readID)
glreport'here'
	--gl.glReadBuffer(gl.GL_BACK) -- restore default ... causes GL error
--glreport'here'
	self.mouseOverID = readID[0]

	-- shader outputs color attachment #0 only, not #1 == ID ...
	self.lineObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
	self.lineObj:draw()
glreport'here'

	self.fb:unbind()
glreport'here'

	self.blitObj:draw()
glreport'here'

	App.super.update(self, ...)
glreport'here'
end

App.updateGUI = |:| do
	if self.mouseOverID and self.mouseOverID ~= -1 then
		local body = self.bodyForID[self.mouseOverID]
		ig.igBeginTooltip()
		ig.igText(self.mouseOverID..(body and ': '..tostring(body.name) or ''))
		ig.igEndTooltip()
		if body and self.mouse.leftPress then	-- look at
			self.view.pos += body.pos - self.view.orbit
			self.view.orbit = body.pos:clone()
		end
	end
end

return App():run()
